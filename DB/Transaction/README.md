# Transaction

- 트랜 잭션이란 데이터 베이스의 일련의 수행과정에 대한 원자성 그리고 동시성 환경에서의 제어를 보장하기 위한 기능이다.
  ACID 원칙을 통해서 위의 조건을 만족한다

## 원자성 (Atomicity)

- 원자성이란 하나의 수행동작이 완전히 실행되거나, 실행되지 않거나 되는 것을 의미한다. 그니깐 A 가 B 한테 돈을 입금하는데
  A 는 입금 했는데 B 에 들어가지 않았다면 완전히 롤백되어 A 의 돈도 Rollback 되어야 한다는 것이다.

## 일관성 (Consistency)

- 일관성은 데이터 베이스에 트랜잭션 작업이 성공하면 일관적인 DB 상태를 유지하는 것을 말합니다. 쉽게 얘기하면 금액 작업이 종료됬는데
  컬럼타입이 갑자기 INT 에서 BIGINT 로 바뀌면 안된다는 뜻, 뭐 그리고 외래키 관련해서도 그럴수 있을거다, 한쪽 에서 키가 바뀌었는데 외래키 참조하는 쪽도 바뀌어야 하지 않겠는가? 이런것들이 일관성을 유지하는 것이다.

## 고립성 (Isolation)

- 트랜잭션을 수행 시 다른 트랜잭션이 끼어들지 못하게 함을 의미합니다. 하지만 이는 DB 마다 고립단계(고립 정책) 또는 데이터베이스 자체의 고립 단계 이 달라 내용이 약간은
  변질 될 수도 있다고 생각합니다..

## 지속성 (Durability)

- DB 가 영속성으로 저장하기 위해 저장된 시스템인 만큼, 한번 실행된 트랜잭션은 영원히 반영되야 함을 의미합니다.

# 고립레벨(Isolation Level)

- 이 부분은 직접 두개의 트랜잭션으로 실험해보는걸 추천한다.. 직접해보기 전까지 이해하기 힘들수도? 그리고 쉽게 적은거지 절대 이렇게 간단하게 이해하면 안된다. 면접에서 간단하게 설명하기 위해 적은것뿐.. 원래는 로그 부분(UNDO, REDO) 그리고 MVCC 를 간단하게 공부하고 트랜잭션을 보는것이 좋다

## UNCOMMITTED READ

- 쉽게 한글 그대로 커밋되지 않은걸 읽어오는 걸 뜻한다, 예를 들면 A 가 11번 컬럼에 대한 작업을 진행하는 트랜잭션이며,
  현재 값은 수정되었으나 아직 Commit 되지 않은 상태라고 했을때, B 가 SELECT 를 하면 커밋되지 않았으며 A 가 수정한 값을 읽어오게 된다. 만약 A 의 트랜잭션이 Commit 되지 않고 롤백됬다면, B 는 헛값을 읽어온게 된다.. 그래서 이 UNCOMMITTED READ 는 추천하지 않는 방식으로 알고 있다.

## COMMITTED READ

- 커밋된 읽기는 위의 방식보다는 훨씬 나은 방식이다. 말그대로 커밋된 데이터만 읽어오는 것인데 생각해보면 오류가 없고 완벽할 것 같지만 아래와 같은 오류가 있을 수 있다. 만약 11번 콜럼에 A 가 만원을 추가했고, 아직 커밋되지 않았다고 해보자. 근데 B 가 SELECT 를 날렸더니 아직은 0원인 상태이다. 그리고 B 는 트랜잭션 내에서 여러가지 작업들을 진행중이며, 도중에 A 가 커밋되었다. B 의 트랜잭션 내부에는 A 금액을 기반으로 계산하는 것이 있었는데, 이번 SELECT 에서는 만원이 들어왔다. B 의 계산은 따라서 틀리게 되었다.. 동일 트랜잭션 안에서 A 의 값이 바뀌었기 때문이다. 이런걸 REAPEATABLE READ 가 보장되지 않아 일어나는 오류라고 한다.

## REAPEATABLE READ

- 사실 COMMITTED READ 나 REAPEATABLE READ 나 UNDO LOG 에서 읽어오는 것은 같으나, REAPEATABLE READ 는 트랜잭션 시작시 가장 오래된 로그를 읽어온다. 즉 위의 B 의 트랜잭션 내에서는 무조건 A 는 한가지 값이라는 것이다. 그래서 동일 트랜잭션 내 쿼리의 결과는 항상 같다! 이 부분이 이해가 안간다면 MVCC 를 공부하고 오는게 좋다~! MySQL 의 InnoDB REAPEATABLE READ 방식을 DEFAULT 로 쓰고 있는 것으로 알고 있다.
